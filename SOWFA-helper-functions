# Make a directory to store log files in if it does not already exist.
mkLogsDir()
{
   if [ ! -d logs ]
   then
       mkdir logs
   fi
}



# Local refinement performed on one core.
refineMeshLocalSerial()
{
   # Refine selected portions of the mesh.  For each refinement step, use topoSet to
   # select regions of the mesh defined in files "system/topoSet/topoSetDict.local.N"
   # where N is the integer refinement step.  We call the base mesh created with blockMesh
   # the level 0 mesh, so any refinement starts at level 1.  Once the grid cells are, 
   # selected, refineHexMesh is used to cut the selected grid cells in half in each 
   # direction and to update the solution file to reflect the refinement.

   # Make a directory in which to collect log files.
   mkLogsDir

   # Enter the topoSet followed by refineHexMesh cycle.
   i=1
   while [ $i -le $1 ]
   do
      echo "   -Performing level $i local refinement with topoSet/refineHexMesh"
      echo "      *selecting cells to refine..."
      topoSet -dict system/topoSet/topoSetDict.local.level$i > logs/log.topoSet.local.level$i 2>&1

      echo "      *refining cells..."
      refineHexMesh local.level$i -overwrite > logs/log.refineHexMesh.local.level.$i 2>&1

      let i=i+1
   done
}




# Global refinement performed in parallel.
refineMeshGlobalParallel()
{
   # Refine all mesh cells by as many levels as specified, cutting each cell in
   # half in each direction each time.  This does not update the solution file.

   # Make a directory in which to collect log files.
   mkLogsDir

   i=1
   while [ $i -le $1 ]
   do
      echo "   -Performing level $i global refinement with refineMesh"
      echo "      *refining cells..."
      mpirun -np $cores refineMesh -all -parallel -overwrite > logs/log.refineMesh.global.$i 2>&1

      let i=i+1
   done
}


# Perform a tiled interpolated copy of a source solution onto this mesh
tiledMapFields()
{
   # Set variables to input arguments
   nTranslations_=$1
   nCoresMap_=$2
   translationVectorX_=$3
   translationVectorY_=$4
   translationVectorZ_=$5
   sourceTime_=$6
   sourceCaseDir_=$7

   # Many log files will be created.  Make a directory in which to collect them.
   mkLogsDir

   # Decompose the domain to the number of cores that will do the pseudo-parallel
   # operation of mapFields
   echo "   -Decomposing domain to $nCoresMap_..."
   cd system
   if [ -L decomposeParDict ]
   then 
       rm decomposeParDict
   fi
   ln -s decomposeParDict.sub decomposeParDict
   cd ../
   srun decomposePar -cellDist -force > logs/log.decomposePar.sub 2>&1


   # Tiled mapping works by first taking this mesh and translating it in space to lie
   # over the top of the source mesh, perform the mapping on the overlapping section of
   # mesh, move the mesh again by the length of the source mesh, map, and so on until
   # the destination mesh is completely mapped.

   # Tiling loop
   i=0
   while [ $i -lt $nTranslations_ ]
   do
      echo "   -Performing solution mapping on tile $i..."

      # This part keeps track of how much total destination mesh translation has occured
      # such that in the end, we can move the destination mesh back to its original position.     
      invtx=`echo "-1.0*($i+1)*$translationVectorX_" | bc`
      invty=`echo "-1.0*($i+1)*$translationVectorY_" | bc`
      invtz=`echo "-1.0*($i+1)*$translationVectorZ_" | bc`

      # Move the destination mesh such that the current "tile" overlaps the source mesh.
      echo "      -transforming points by vector ("$translationVectorX_ $translationVectorY_ $translationVectorZ_")..."
      istr="($translationVectorX_ $translationVectorY_ $translationVectorZ_)"
      srun -n $nCoresMap_ transformPoints -translate "$istr" -parallel > logs/log.transformPoints.$i 2>&1

      # Run mapFields to do the interpolation from source to destination mesh.  We can do this 
      # in pseudo-parallel by having a core work on each processor directory created earlier.
      echo "      -spawning mapFields on core:"
      j=0
      while [ $j -lt $nCoresMap_ ]
      do
         echo "             $j..."
         mapFields -case processor$j -mapMethod mapNearest -sourceTime $sourceTime_ -parallelSource $sourceCaseDir_ > logs/log.mapFields.tile$i.core$j 2>&1 &
         let j=j+1
      done
      
      # The "wait" command is there so that all mapFields jobs must finish before moving ahead.
      echo "      -waiting for all mapFields jobs to complete..."
      wait
      echo "      -all mapFields jobs complete..."        

      let i=i+1
   done

   # Move the destination mesh back to its original position.
   echo "   -Translating back to original with vector ("$invtx $invty $invtz ")..."
   istr="($invtx $invty $invtz)"
   srun -n $nCoresMap_ transformPoints -translate "$istr" -parallel > logs/log.transformPoints.final 2>&1

   # Since the mapping was done in pseudo-parallel, reconstruct the domain.
   echo "   -Reconstructing domain..."
   reconstructPar -time $sourceTime_ > logs/log.reconstructPar.sub 2>&1
}
